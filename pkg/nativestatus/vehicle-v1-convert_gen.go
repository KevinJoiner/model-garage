// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package nativestatus

import (
	"errors"
	"fmt"

	"github.com/DIMO-Network/model-garage/pkg/convert"
	"github.com/DIMO-Network/model-garage/pkg/vss"
	"github.com/tidwall/gjson"
)

var errNotFound = errors.New("field not found")

// SignalsFromV1Data creates a slice of vss.Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromV1Data(baseSignal vss.Signal, jsonData []byte) ([]vss.Signal, []error) {
	var retSignals []vss.Signal

	var val any
	var err error
	var errs []error

	val, err = AngularVelocityYawFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'AngularVelocityYaw': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "angularVelocityYaw",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelLeftSpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelLeftSpeed': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "chassisAxleRow1WheelLeftSpeed",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "chassisAxleRow1WheelLeftTirePressure",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelRightSpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelRightSpeed': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "chassisAxleRow1WheelRightSpeed",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "chassisAxleRow1WheelRightTirePressure",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "chassisAxleRow2WheelLeftTirePressure",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "chassisAxleRow2WheelRightTirePressure",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationAltitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationAltitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "currentLocationAltitude",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationIsRedactedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationIsRedacted': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "currentLocationIsRedacted",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLatitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLatitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "currentLocationLatitude",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLongitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLongitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "currentLocationLongitude",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = DIMOAftermarketHDOPFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketHDOP': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "dimoAftermarketHDOP",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = DIMOAftermarketNSATFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketNSAT': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "dimoAftermarketNSAT",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = DIMOAftermarketSSIDFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketSSID': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "dimoAftermarketSSID",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = DIMOAftermarketWPAStateFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketWPAState': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "dimoAftermarketWPAState",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ExteriorAirTemperatureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ExteriorAirTemperature': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "exteriorAirTemperature",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = LowVoltageBatteryCurrentVoltageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'LowVoltageBatteryCurrentVoltage': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "lowVoltageBatteryCurrentVoltage",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDBarometricPressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDBarometricPressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdBarometricPressure",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDCommandedEGRFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDCommandedEGR': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdCommandedEGR",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDCommandedEVAPFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDCommandedEVAP': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdCommandedEVAP",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDDistanceSinceDTCClearFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDDistanceSinceDTCClear': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdDistanceSinceDTCClear",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDDistanceWithMILFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDDistanceWithMIL': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdDistanceWithMIL",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDEngineLoadFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDEngineLoad': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdEngineLoad",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDFuelPressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDFuelPressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdFuelPressure",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDIntakeTempFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDIntakeTemp': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdIntakeTemp",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDLongTermFuelTrim1FromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDLongTermFuelTrim1': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdLongTermFuelTrim1",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDMAPFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDMAP': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdMAP",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDO2WRSensor1VoltageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDO2WRSensor1Voltage': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdO2WRSensor1Voltage",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDO2WRSensor2VoltageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDO2WRSensor2Voltage': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdO2WRSensor2Voltage",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDRunTimeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDRunTime': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdRunTime",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDShortTermFuelTrim1FromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDShortTermFuelTrim1': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdShortTermFuelTrim1",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDWarmupsSinceDTCClearFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDWarmupsSinceDTCClear': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "obdWarmupsSinceDTCClear",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineECTFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineECT': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainCombustionEngineECT",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEngineOilLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainCombustionEngineEngineOilLevel",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEngineOilRelativeLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEngineOilRelativeLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainCombustionEngineEngineOilRelativeLevel",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineMAFFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineMAF': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainCombustionEngineMAF",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineSpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineSpeed': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainCombustionEngineSpeed",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineTPSFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineTPS': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainCombustionEngineTPS",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineTorqueFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineTorque': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainCombustionEngineTorque",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemAbsoluteLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainFuelSystemAbsoluteLevel",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemRelativeLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemRelativeLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainFuelSystemRelativeLevel",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemSupportedFuelTypesFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemSupportedFuelTypes': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainFuelSystemSupportedFuelTypes",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainRangeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainRange': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainRange",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryChargingChargeLimitFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryChargingChargeLimit': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTractionBatteryChargingChargeLimit",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryChargingIsCharging': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTractionBatteryChargingIsCharging",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryCurrentPowerFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryCurrentPower': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTractionBatteryCurrentPower",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryCurrentVoltageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryCurrentVoltage': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTractionBatteryCurrentVoltage",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryGrossCapacityFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryGrossCapacity': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTractionBatteryGrossCapacity",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryStateOfChargeCurrent': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTractionBatteryStateOfChargeCurrent",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryTemperatureAverageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryTemperatureAverage': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTractionBatteryTemperatureAverage",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionCurrentGearFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionCurrentGear': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTransmissionCurrentGear",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionTemperatureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionTemperature': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTransmissionTemperature",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionTravelledDistanceFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionTravelledDistance': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainTransmissionTravelledDistance",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTypeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainType': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "powertrainType",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ServiceDistanceToServiceFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ServiceDistanceToService': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "serviceDistanceToService",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = SpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'Speed': %w", err))
		}
	} else {
		sig := vss.Signal{
			SignalValue: vss.SignalValue{
				Name:      "speed",
				Timestamp: baseSignal.Timestamp,
			},
			TokenID: baseSignal.TokenID,
			Source:  baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
	return retSignals, errs
}

// AngularVelocityYawFromV1Data converts the given JSON data to a float64.
func AngularVelocityYawFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.yawRate")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToAngularVelocityYaw0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.yawRate': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.yawRate' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'AngularVelocityYaw'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelLeftSpeedFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftSpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.frontlLeftWheelSpeed")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.frontlLeftWheelSpeed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.frontlLeftWheelSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelLeftSpeed'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelLeftTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.frontLeft")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.frontLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.frontLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.tiresFrontLeft")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tiresFrontLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tiresFrontLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightSpeedFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightSpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.frontRightWheelSpeed")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.frontRightWheelSpeed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.frontRightWheelSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelRightSpeed'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.frontRight")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.frontRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.frontRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.tiresFrontRight")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tiresFrontRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tiresFrontRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelLeftTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.backLeft")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.backLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.backLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.tiresBackLeft")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelLeftTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tiresBackLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tiresBackLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelRightTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.backRight")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.backRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.backRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.tiresBackRight")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelRightTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tiresBackRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tiresBackRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationAltitudeFromV1Data converts the given JSON data to a float64.
func CurrentLocationAltitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.altitude")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationAltitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.altitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.altitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationAltitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationIsRedactedFromV1Data converts the given JSON data to a float64.
func CurrentLocationIsRedactedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.isRedacted")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(bool)
		if ok {
			retVal, err := ToCurrentLocationIsRedacted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.isRedacted': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.isRedacted' is not of type 'bool' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationIsRedacted'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLatitudeFromV1Data converts the given JSON data to a float64.
func CurrentLocationLatitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.latitude")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLatitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.latitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.latitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLatitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLongitudeFromV1Data converts the given JSON data to a float64.
func CurrentLocationLongitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.longitude")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLongitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.longitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.longitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLongitude'", errNotFound)
	}

	return ret, errs
}

// DIMOAftermarketHDOPFromV1Data converts the given JSON data to a float64.
func DIMOAftermarketHDOPFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.hdop")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToDIMOAftermarketHDOP0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.hdop': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.hdop' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'DIMOAftermarketHDOP'", errNotFound)
	}

	return ret, errs
}

// DIMOAftermarketNSATFromV1Data converts the given JSON data to a float64.
func DIMOAftermarketNSATFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.nsat")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToDIMOAftermarketNSAT0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.nsat': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.nsat' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'DIMOAftermarketNSAT'", errNotFound)
	}

	return ret, errs
}

// DIMOAftermarketSSIDFromV1Data converts the given JSON data to a string.
func DIMOAftermarketSSIDFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.ssid")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToDIMOAftermarketSSID0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.ssid': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.ssid' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.wifi.ssid")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToDIMOAftermarketSSID1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.wifi.ssid': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.wifi.ssid' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'DIMOAftermarketSSID'", errNotFound)
	}

	return ret, errs
}

// DIMOAftermarketWPAStateFromV1Data converts the given JSON data to a string.
func DIMOAftermarketWPAStateFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.wpa_state")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToDIMOAftermarketWPAState0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.wpa_state': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.wpa_state' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.wifi.wpaState")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToDIMOAftermarketWPAState1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.wifi.wpaState': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.wifi.wpaState' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'DIMOAftermarketWPAState'", errNotFound)
	}

	return ret, errs
}

// ExteriorAirTemperatureFromV1Data converts the given JSON data to a float64.
func ExteriorAirTemperatureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.ambientAirTemp")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToExteriorAirTemperature0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.ambientAirTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.ambientAirTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.ambientTemp")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToExteriorAirTemperature1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.ambientTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.ambientTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ExteriorAirTemperature'", errNotFound)
	}

	return ret, errs
}

// LowVoltageBatteryCurrentVoltageFromV1Data converts the given JSON data to a float64.
func LowVoltageBatteryCurrentVoltageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.batteryVoltage")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToLowVoltageBatteryCurrentVoltage0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.batteryVoltage': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.batteryVoltage' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'LowVoltageBatteryCurrentVoltage'", errNotFound)
	}

	return ret, errs
}

// OBDBarometricPressureFromV1Data converts the given JSON data to a float64.
func OBDBarometricPressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.barometricPressure")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDBarometricPressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.barometricPressure': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.barometricPressure' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDBarometricPressure'", errNotFound)
	}

	return ret, errs
}

// OBDCommandedEGRFromV1Data converts the given JSON data to a float64.
func OBDCommandedEGRFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.commandedEgr")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDCommandedEGR0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.commandedEgr': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.commandedEgr' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDCommandedEGR'", errNotFound)
	}

	return ret, errs
}

// OBDCommandedEVAPFromV1Data converts the given JSON data to a float64.
func OBDCommandedEVAPFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.evap")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDCommandedEVAP0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.evap': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.evap' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDCommandedEVAP'", errNotFound)
	}

	return ret, errs
}

// OBDDistanceSinceDTCClearFromV1Data converts the given JSON data to a float64.
func OBDDistanceSinceDTCClearFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.distanceSinceDtcClear")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDDistanceSinceDTCClear0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.distanceSinceDtcClear': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.distanceSinceDtcClear' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDDistanceSinceDTCClear'", errNotFound)
	}

	return ret, errs
}

// OBDDistanceWithMILFromV1Data converts the given JSON data to a float64.
func OBDDistanceWithMILFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.distanceWMil")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDDistanceWithMIL0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.distanceWMil': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.distanceWMil' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDDistanceWithMIL'", errNotFound)
	}

	return ret, errs
}

// OBDEngineLoadFromV1Data converts the given JSON data to a float64.
func OBDEngineLoadFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.engineLoad")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDEngineLoad0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.engineLoad': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.engineLoad' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDEngineLoad'", errNotFound)
	}

	return ret, errs
}

// OBDFuelPressureFromV1Data converts the given JSON data to a float64.
func OBDFuelPressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelTankPressure")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDFuelPressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelTankPressure': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelTankPressure' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDFuelPressure'", errNotFound)
	}

	return ret, errs
}

// OBDIntakeTempFromV1Data converts the given JSON data to a float64.
func OBDIntakeTempFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.intakeTemp")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDIntakeTemp0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.intakeTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.intakeTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDIntakeTemp'", errNotFound)
	}

	return ret, errs
}

// OBDLongTermFuelTrim1FromV1Data converts the given JSON data to a float64.
func OBDLongTermFuelTrim1FromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.longTermFuelTrim1")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDLongTermFuelTrim10(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.longTermFuelTrim1': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.longTermFuelTrim1' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDLongTermFuelTrim1'", errNotFound)
	}

	return ret, errs
}

// OBDMAPFromV1Data converts the given JSON data to a float64.
func OBDMAPFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.intakePressure")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDMAP0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.intakePressure': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.intakePressure' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDMAP'", errNotFound)
	}

	return ret, errs
}

// OBDO2WRSensor1VoltageFromV1Data converts the given JSON data to a float64.
func OBDO2WRSensor1VoltageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.oxygenSensor1")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDO2WRSensor1Voltage0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.oxygenSensor1': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.oxygenSensor1' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDO2WRSensor1Voltage'", errNotFound)
	}

	return ret, errs
}

// OBDO2WRSensor2VoltageFromV1Data converts the given JSON data to a float64.
func OBDO2WRSensor2VoltageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.oxygenSensor2")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDO2WRSensor2Voltage0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.oxygenSensor2': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.oxygenSensor2' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDO2WRSensor2Voltage'", errNotFound)
	}

	return ret, errs
}

// OBDRunTimeFromV1Data converts the given JSON data to a float64.
func OBDRunTimeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.runTime")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDRunTime0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.runTime': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.runTime' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDRunTime'", errNotFound)
	}

	return ret, errs
}

// OBDShortTermFuelTrim1FromV1Data converts the given JSON data to a float64.
func OBDShortTermFuelTrim1FromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.shortTermFuelTrim1")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDShortTermFuelTrim10(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.shortTermFuelTrim1': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.shortTermFuelTrim1' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDShortTermFuelTrim1'", errNotFound)
	}

	return ret, errs
}

// OBDWarmupsSinceDTCClearFromV1Data converts the given JSON data to a float64.
func OBDWarmupsSinceDTCClearFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.warmupsSinceDtcClear")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDWarmupsSinceDTCClear0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.warmupsSinceDtcClear': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.warmupsSinceDtcClear' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDWarmupsSinceDTCClear'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineECTFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineECTFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.coolantTemp")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineECT0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.coolantTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.coolantTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineECT'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilLevelFromV1Data converts the given JSON data to a string.
func PowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.oil")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.oil': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.oil' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.oilLife")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilLevel1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.oilLife': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.oilLife' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEngineOilLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilRelativeLevelFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineEngineOilRelativeLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.oil")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilRelativeLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.oil': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.oil' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEngineOilRelativeLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineMAFFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineMAFFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.maf")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineMAF0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.maf': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.maf' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineMAF'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineSpeedFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineSpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.rpm")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.rpm': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.rpm' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.engineSpeed")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineSpeed1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.engineSpeed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.engineSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineSpeed'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineTPSFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineTPSFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.throttlePosition")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineTPS0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.throttlePosition': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.throttlePosition' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineTPS'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineTorqueFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineTorqueFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.engineTorque")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineTorque0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.engineTorque': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.engineTorque' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineTorque'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemAbsoluteLevelFromV1Data converts the given JSON data to a float64.
func PowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelLevelLiters")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainFuelSystemAbsoluteLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelLevelLiters': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelLevelLiters' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemAbsoluteLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemRelativeLevelFromV1Data converts the given JSON data to a float64.
func PowertrainFuelSystemRelativeLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelLevel")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainFuelSystemRelativeLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelLevel': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelLevel' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.fuelPercentRemaining")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainFuelSystemRelativeLevel1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelPercentRemaining': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelPercentRemaining' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemRelativeLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemSupportedFuelTypesFromV1Data converts the given JSON data to a string.
func PowertrainFuelSystemSupportedFuelTypesFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelType")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemSupportedFuelTypes0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelType': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelType' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemSupportedFuelTypes'", errNotFound)
	}

	return ret, errs
}

// PowertrainRangeFromV1Data converts the given JSON data to a float64.
func PowertrainRangeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.range")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainRange0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.range': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.range' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainRange'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingChargeLimitFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingChargeLimitFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.chargeLimit")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingChargeLimit0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.chargeLimit': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.chargeLimit' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryChargingChargeLimit'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingIsChargingFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charging")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(bool)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingIsCharging0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charging': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charging' is not of type 'bool' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryChargingIsCharging'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryCurrentPowerFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryCurrentPowerFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charger.power")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryCurrentPower0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charger.power': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charger.power' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryCurrentPower'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryCurrentVoltageFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryCurrentVoltageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.hvBatteryVoltage")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryCurrentVoltage0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.hvBatteryVoltage': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.hvBatteryVoltage' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryCurrentVoltage'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryGrossCapacityFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryGrossCapacityFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.batteryCapacity")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryGrossCapacity0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.batteryCapacity': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.batteryCapacity' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryGrossCapacity'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryStateOfChargeCurrentFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.soc")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryStateOfChargeCurrent0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.soc': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.soc' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryStateOfChargeCurrent'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryTemperatureAverageFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryTemperatureAverageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.hvBatteryCoolantTemperature")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryTemperatureAverage0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.hvBatteryCoolantTemperature': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.hvBatteryCoolantTemperature' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryTemperatureAverage'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionCurrentGearFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionCurrentGearFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.gearSelection")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTransmissionCurrentGear0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.gearSelection': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.gearSelection' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionCurrentGear'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionTemperatureFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionTemperatureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.atfTemperature")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTransmissionTemperature0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.atfTemperature': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.atfTemperature' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionTemperature'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionTravelledDistanceFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionTravelledDistanceFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.odometer")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTransmissionTravelledDistance0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.odometer': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.odometer' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionTravelledDistance'", errNotFound)
	}

	return ret, errs
}

// PowertrainTypeFromV1Data converts the given JSON data to a string.
func PowertrainTypeFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelType")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainType0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelType': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelType' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainType'", errNotFound)
	}

	return ret, errs
}

// ServiceDistanceToServiceFromV1Data converts the given JSON data to a float64.
func ServiceDistanceToServiceFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.serviceInterval")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToServiceDistanceToService0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.serviceInterval': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.serviceInterval' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ServiceDistanceToService'", errNotFound)
	}

	return ret, errs
}

// SpeedFromV1Data converts the given JSON data to a float64.
func SpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.vehicleSpeed")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.vehicleSpeed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.vehicleSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.speed")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToSpeed1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.speed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.speed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'Speed'", errNotFound)
	}

	return ret, errs
}
