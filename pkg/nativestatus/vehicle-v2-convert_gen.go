// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package nativestatus

import (
	"errors"
	"fmt"

	"github.com/DIMO-Network/model-garage/pkg/convert"
	"github.com/DIMO-Network/model-garage/pkg/vss"
	"github.com/tidwall/gjson"
)

// SignalsFromData converts the given JSON data to a slice of signals.
func SignalsFromV2Data(originalDoc []byte, baseSignal vss.Signal, signalName string, sigResult gjson.Result) ([]vss.Signal, error) {
	valResult := sigResult.Get("value")
	if !valResult.Exists() {
		return nil, errors.New("value field not found")
	}
	ret := make([]vss.Signal, 0)
	var retErrs error

	switch signalName {
	case "altitude":
		val0, err := CurrentLocationAltitudeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'altitude': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationAltitude",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "ambientAirTemp":
		val0, err := ExteriorAirTemperatureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'ambientAirTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "exteriorAirTemperature",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "ambientTemp":
		val0, err := ExteriorAirTemperatureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'ambientTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "exteriorAirTemperature",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "atfTemperature":
		val0, err := PowertrainTransmissionTemperatureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'atfTemperature': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTransmissionTemperature",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "barometricPressure":
		val0, err := OBDBarometricPressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'barometricPressure': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdBarometricPressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "batteryCapacity":
		val0, err := PowertrainTractionBatteryGrossCapacityFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'batteryCapacity': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryGrossCapacity",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "batteryVoltage":
		val0, err := LowVoltageBatteryCurrentVoltageFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'batteryVoltage': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "lowVoltageBatteryCurrentVoltage",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "chargeLimit":
		val0, err := PowertrainTractionBatteryChargingChargeLimitFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'chargeLimit': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryChargingChargeLimit",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "charger.power":
		val0, err := PowertrainTractionBatteryCurrentPowerFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'charger.power': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryCurrentPower",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "charging":
		val0, err := PowertrainTractionBatteryChargingIsChargingFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'charging': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryChargingIsCharging",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "commandedEgr":
		val0, err := OBDCommandedEGRFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'commandedEgr': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdCommandedEGR",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "coolantTemp":
		val0, err := PowertrainCombustionEngineECTFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'coolantTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineECT",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "dcConveterRequestedVoltage":
		val0, err := PowertrainTractionBatteryChargingChargeVoltageDCFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'dcConveterRequestedVoltage': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryChargingChargeVoltageDC",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "distanceSinceDtcClear":
		val0, err := OBDDistanceSinceDTCClearFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'distanceSinceDtcClear': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdDistanceSinceDTCClear",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "distanceWMil":
		val0, err := OBDDistanceWithMILFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'distanceWMil': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdDistanceWithMIL",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "engineLoad":
		val0, err := OBDEngineLoadFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'engineLoad': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdEngineLoad",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "engineSpeed":
		val0, err := PowertrainCombustionEngineSpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'engineSpeed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineSpeed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "engineTorque":
		val0, err := PowertrainCombustionEngineTorqueFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'engineTorque': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineTorque",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "evap":
		val0, err := OBDCommandedEVAPFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'evap': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdCommandedEVAP",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "frontRightWheelSpeed":
		val0, err := ChassisAxleRow1WheelRightSpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'frontRightWheelSpeed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelRightSpeed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "frontlLeftWheelSpeed":
		val0, err := ChassisAxleRow1WheelLeftSpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'frontlLeftWheelSpeed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelLeftSpeed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelLevel":
		val0, err := PowertrainFuelSystemRelativeLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelLevel': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainFuelSystemRelativeLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelLevelLiters":
		val0, err := PowertrainFuelSystemAbsoluteLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelLevelLiters': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainFuelSystemAbsoluteLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelPercentRemaining":
		val0, err := PowertrainFuelSystemRelativeLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelPercentRemaining': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainFuelSystemRelativeLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelTankPressure":
		val0, err := OBDFuelPressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelTankPressure': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdFuelPressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelType":
		val0, err := PowertrainFuelSystemSupportedFuelTypesFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelType': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainFuelSystemSupportedFuelTypes",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
		val1, err := PowertrainTypeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelType': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainType",
			}
			sig.SetValue(val1)
			ret = append(ret, sig)
		}
	case "gearSelection":
		val0, err := PowertrainTransmissionCurrentGearFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'gearSelection': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTransmissionCurrentGear",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "hdop":
		val0, err := DIMOAftermarketHDOPFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'hdop': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketHDOP",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "hvBatteryCoolantTemperature":
		val0, err := PowertrainTractionBatteryTemperatureAverageFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'hvBatteryCoolantTemperature': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryTemperatureAverage",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "hvBatteryVoltage":
		val0, err := PowertrainTractionBatteryCurrentVoltageFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'hvBatteryVoltage': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryCurrentVoltage",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "intakePressure":
		val0, err := OBDMAPFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'intakePressure': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdMAP",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "intakeTemp":
		val0, err := OBDIntakeTempFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'intakeTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdIntakeTemp",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "isRedacted":
		val0, err := CurrentLocationIsRedactedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'isRedacted': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationIsRedacted",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "latitude":
		val0, err := CurrentLocationLatitudeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'latitude': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationLatitude",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "longTermFuelTrim1":
		val0, err := OBDLongTermFuelTrim1FromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'longTermFuelTrim1': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdLongTermFuelTrim1",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "longitude":
		val0, err := CurrentLocationLongitudeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'longitude': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationLongitude",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "maf":
		val0, err := PowertrainCombustionEngineMAFFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'maf': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineMAF",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "nsat":
		val0, err := DIMOAftermarketNSATFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'nsat': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketNSAT",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "odometer":
		val0, err := PowertrainTransmissionTravelledDistanceFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'odometer': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTransmissionTravelledDistance",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "oil":
		val0, err := PowertrainCombustionEngineEngineOilLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'oil': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineEngineOilLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
		val1, err := PowertrainCombustionEngineEngineOilRelativeLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'oil': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineEngineOilRelativeLevel",
			}
			sig.SetValue(val1)
			ret = append(ret, sig)
		}
	case "oilLife":
		val0, err := PowertrainCombustionEngineEngineOilLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'oilLife': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineEngineOilLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "oxygenSensor1":
		val0, err := OBDO2WRSensor1VoltageFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'oxygenSensor1': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdO2WRSensor1Voltage",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "oxygenSensor2":
		val0, err := OBDO2WRSensor2VoltageFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'oxygenSensor2': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdO2WRSensor2Voltage",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "range":
		val0, err := PowertrainRangeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'range': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainRange",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "rpm":
		val0, err := PowertrainCombustionEngineSpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'rpm': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineSpeed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "runTime":
		val0, err := OBDRunTimeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'runTime': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdRunTime",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "serviceInterval":
		val0, err := ServiceDistanceToServiceFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'serviceInterval': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "serviceDistanceToService",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "shortTermFuelTrim1":
		val0, err := OBDShortTermFuelTrim1FromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'shortTermFuelTrim1': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdShortTermFuelTrim1",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "soc":
		val0, err := PowertrainTractionBatteryStateOfChargeCurrentFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'soc': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryStateOfChargeCurrent",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "speed":
		val0, err := SpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'speed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "speed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "ssid":
		val0, err := DIMOAftermarketSSIDFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'ssid': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketSSID",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "throttlePosition":
		val0, err := PowertrainCombustionEngineTPSFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'throttlePosition': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineTPS",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tires.backLeft":
		val0, err := ChassisAxleRow2WheelLeftTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.backLeft': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow2WheelLeftTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tires.backRight":
		val0, err := ChassisAxleRow2WheelRightTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.backRight': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow2WheelRightTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tires.frontLeft":
		val0, err := ChassisAxleRow1WheelLeftTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.frontLeft': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelLeftTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tires.frontRight":
		val0, err := ChassisAxleRow1WheelRightTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.frontRight': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelRightTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tiresBackLeft":
		val0, err := ChassisAxleRow2WheelLeftTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tiresBackLeft': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow2WheelLeftTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tiresBackRight":
		val0, err := ChassisAxleRow2WheelRightTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tiresBackRight': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow2WheelRightTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tiresFrontLeft":
		val0, err := ChassisAxleRow1WheelLeftTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tiresFrontLeft': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelLeftTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tiresFrontRight":
		val0, err := ChassisAxleRow1WheelRightTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tiresFrontRight': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelRightTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "vehicleSpeed":
		val0, err := SpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'vehicleSpeed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "speed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "warmupsSinceDtcClear":
		val0, err := OBDWarmupsSinceDTCClearFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'warmupsSinceDtcClear': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdWarmupsSinceDTCClear",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "wifi.ssid":
		val0, err := DIMOAftermarketSSIDFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'wifi.ssid': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketSSID",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "wifi.wpaState":
		val0, err := DIMOAftermarketWPAStateFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'wifi.wpaState': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketWPAState",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "wpa_state":
		val0, err := DIMOAftermarketWPAStateFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'wpa_state': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketWPAState",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "yawRate":
		val0, err := AngularVelocityYawFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'yawRate': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "angularVelocityYaw",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	default:
		// do nothing
	}
	return ret, retErrs
}

// AngularVelocityYawFromData converts the given JSON data to a float64.
func AngularVelocityYawFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToAngularVelocityYaw0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'yawRate': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'yawRate' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow1WheelLeftSpeedFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftSpeedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelLeftSpeed0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'frontlLeftWheelSpeed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'frontlLeftWheelSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow1WheelLeftTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelLeftTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.frontLeft': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.frontLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelLeftTirePressure1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tiresFrontLeft': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tiresFrontLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightSpeedFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightSpeedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelRightSpeed0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'frontRightWheelSpeed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'frontRightWheelSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelRightTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.frontRight': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.frontRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelRightTirePressure1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tiresFrontRight': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tiresFrontRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow2WheelLeftTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow2WheelLeftTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow2WheelLeftTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.backLeft': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.backLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow2WheelLeftTirePressure1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tiresBackLeft': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tiresBackLeft' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow2WheelRightTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow2WheelRightTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow2WheelRightTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.backRight': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.backRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow2WheelRightTirePressure1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tiresBackRight': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tiresBackRight' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationAltitudeFromData converts the given JSON data to a float64.
func CurrentLocationAltitudeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToCurrentLocationAltitude0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'altitude': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'altitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationIsRedactedFromData converts the given JSON data to a float64.
func CurrentLocationIsRedactedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(bool)
	if ok {
		ret, err = ToCurrentLocationIsRedacted0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'isRedacted': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'isRedacted' is not of type 'bool' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationLatitudeFromData converts the given JSON data to a float64.
func CurrentLocationLatitudeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToCurrentLocationLatitude0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'latitude': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'latitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationLongitudeFromData converts the given JSON data to a float64.
func CurrentLocationLongitudeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToCurrentLocationLongitude0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'longitude': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'longitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketHDOPFromData converts the given JSON data to a float64.
func DIMOAftermarketHDOPFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToDIMOAftermarketHDOP0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'hdop': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'hdop' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketNSATFromData converts the given JSON data to a float64.
func DIMOAftermarketNSATFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToDIMOAftermarketNSAT0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'nsat': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'nsat' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketSSIDFromData converts the given JSON data to a string.
func DIMOAftermarketSSIDFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketSSID0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'ssid': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'ssid' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketSSID1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'wifi.ssid': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'wifi.ssid' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketWPAStateFromData converts the given JSON data to a string.
func DIMOAftermarketWPAStateFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketWPAState0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'wpa_state': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'wpa_state' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketWPAState1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'wifi.wpaState': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'wifi.wpaState' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ExteriorAirTemperatureFromData converts the given JSON data to a float64.
func ExteriorAirTemperatureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToExteriorAirTemperature0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'ambientAirTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'ambientAirTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToExteriorAirTemperature1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'ambientTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'ambientTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// LowVoltageBatteryCurrentVoltageFromData converts the given JSON data to a float64.
func LowVoltageBatteryCurrentVoltageFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToLowVoltageBatteryCurrentVoltage0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'batteryVoltage': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'batteryVoltage' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDBarometricPressureFromData converts the given JSON data to a float64.
func OBDBarometricPressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDBarometricPressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'barometricPressure': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'barometricPressure' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDCommandedEGRFromData converts the given JSON data to a float64.
func OBDCommandedEGRFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDCommandedEGR0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'commandedEgr': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'commandedEgr' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDCommandedEVAPFromData converts the given JSON data to a float64.
func OBDCommandedEVAPFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDCommandedEVAP0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'evap': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'evap' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDDistanceSinceDTCClearFromData converts the given JSON data to a float64.
func OBDDistanceSinceDTCClearFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDDistanceSinceDTCClear0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'distanceSinceDtcClear': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'distanceSinceDtcClear' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDDistanceWithMILFromData converts the given JSON data to a float64.
func OBDDistanceWithMILFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDDistanceWithMIL0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'distanceWMil': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'distanceWMil' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDEngineLoadFromData converts the given JSON data to a float64.
func OBDEngineLoadFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDEngineLoad0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'engineLoad': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'engineLoad' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDFuelPressureFromData converts the given JSON data to a float64.
func OBDFuelPressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDFuelPressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelTankPressure': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelTankPressure' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDIntakeTempFromData converts the given JSON data to a float64.
func OBDIntakeTempFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDIntakeTemp0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'intakeTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'intakeTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDLongTermFuelTrim1FromData converts the given JSON data to a float64.
func OBDLongTermFuelTrim1FromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDLongTermFuelTrim10(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'longTermFuelTrim1': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'longTermFuelTrim1' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDMAPFromData converts the given JSON data to a float64.
func OBDMAPFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDMAP0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'intakePressure': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'intakePressure' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDO2WRSensor1VoltageFromData converts the given JSON data to a float64.
func OBDO2WRSensor1VoltageFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDO2WRSensor1Voltage0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'oxygenSensor1': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'oxygenSensor1' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDO2WRSensor2VoltageFromData converts the given JSON data to a float64.
func OBDO2WRSensor2VoltageFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDO2WRSensor2Voltage0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'oxygenSensor2': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'oxygenSensor2' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDRunTimeFromData converts the given JSON data to a float64.
func OBDRunTimeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDRunTime0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'runTime': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'runTime' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDShortTermFuelTrim1FromData converts the given JSON data to a float64.
func OBDShortTermFuelTrim1FromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDShortTermFuelTrim10(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'shortTermFuelTrim1': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'shortTermFuelTrim1' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDWarmupsSinceDTCClearFromData converts the given JSON data to a float64.
func OBDWarmupsSinceDTCClearFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDWarmupsSinceDTCClear0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'warmupsSinceDtcClear': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'warmupsSinceDtcClear' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineECTFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineECTFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineECT0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'coolantTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'coolantTemp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilLevelFromData converts the given JSON data to a string.
func PowertrainCombustionEngineEngineOilLevelFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineEngineOilLevel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'oil': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'oil' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineEngineOilLevel1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'oilLife': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'oilLife' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilRelativeLevelFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineEngineOilRelativeLevelFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineEngineOilRelativeLevel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'oil': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'oil' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineMAFFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineMAFFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineMAF0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'maf': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'maf' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineSpeedFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineSpeedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineSpeed0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'rpm': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'rpm' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineSpeed1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'engineSpeed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'engineSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineTPSFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineTPSFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineTPS0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'throttlePosition': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'throttlePosition' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineTorqueFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineTorqueFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineTorque0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'engineTorque': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'engineTorque' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainFuelSystemAbsoluteLevelFromData converts the given JSON data to a float64.
func PowertrainFuelSystemAbsoluteLevelFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainFuelSystemAbsoluteLevel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelLevelLiters': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelLevelLiters' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainFuelSystemRelativeLevelFromData converts the given JSON data to a float64.
func PowertrainFuelSystemRelativeLevelFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainFuelSystemRelativeLevel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelLevel': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelLevel' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainFuelSystemRelativeLevel1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelPercentRemaining': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelPercentRemaining' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainFuelSystemSupportedFuelTypesFromData converts the given JSON data to a string.
func PowertrainFuelSystemSupportedFuelTypesFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToPowertrainFuelSystemSupportedFuelTypes0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelType': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelType' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainRangeFromData converts the given JSON data to a float64.
func PowertrainRangeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainRange0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'range': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'range' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingChargeLimitFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingChargeLimitFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryChargingChargeLimit0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'chargeLimit': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'chargeLimit' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingChargeVoltageDCFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingChargeVoltageDCFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryChargingChargeVoltageDC0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'dcConveterRequestedVoltage': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'dcConveterRequestedVoltage' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingIsChargingFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingIsChargingFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(bool)
	if ok {
		ret, err = ToPowertrainTractionBatteryChargingIsCharging0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'charging': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'charging' is not of type 'bool' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryCurrentPowerFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryCurrentPowerFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryCurrentPower0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'charger.power': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'charger.power' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryCurrentVoltageFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryCurrentVoltageFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryCurrentVoltage0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'hvBatteryVoltage': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'hvBatteryVoltage' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryGrossCapacityFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryGrossCapacityFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryGrossCapacity0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'batteryCapacity': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'batteryCapacity' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryStateOfChargeCurrentFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryStateOfChargeCurrentFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryStateOfChargeCurrent0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'soc': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'soc' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryTemperatureAverageFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryTemperatureAverageFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryTemperatureAverage0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'hvBatteryCoolantTemperature': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'hvBatteryCoolantTemperature' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTransmissionCurrentGearFromData converts the given JSON data to a float64.
func PowertrainTransmissionCurrentGearFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTransmissionCurrentGear0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'gearSelection': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'gearSelection' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTransmissionTemperatureFromData converts the given JSON data to a float64.
func PowertrainTransmissionTemperatureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTransmissionTemperature0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'atfTemperature': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'atfTemperature' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTransmissionTravelledDistanceFromData converts the given JSON data to a float64.
func PowertrainTransmissionTravelledDistanceFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTransmissionTravelledDistance0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'odometer': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'odometer' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTypeFromData converts the given JSON data to a string.
func PowertrainTypeFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToPowertrainType0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelType': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelType' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// ServiceDistanceToServiceFromData converts the given JSON data to a float64.
func ServiceDistanceToServiceFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToServiceDistanceToService0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'serviceInterval': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'serviceInterval' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}

// SpeedFromData converts the given JSON data to a float64.
func SpeedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToSpeed0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'vehicleSpeed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'vehicleSpeed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToSpeed1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'speed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'speed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}

	return ret, errs
}
