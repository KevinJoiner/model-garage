// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package tesla

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/DIMO-Network/model-garage/pkg/convert"
	"github.com/DIMO-Network/model-garage/pkg/vss"
	"github.com/tidwall/gjson"
)

var errNotFound = errors.New("field not found")

// SignalsFromV1Data creates a slice of vss.SignalValue from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromTesla(jsonData []byte) ([]vss.SignalValue, []error) {
	var retSignals []vss.SignalValue

	var val any
	var ts time.Time
	var err error
	var errs []error

	val, ts, err = ChassisAxleRow1WheelLeftTirePressureFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'ChassisAxleRow1WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "chassisAxleRow1WheelLeftTirePressure",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = ChassisAxleRow1WheelRightTirePressureFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'ChassisAxleRow1WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "chassisAxleRow1WheelRightTirePressure",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = ChassisAxleRow2WheelLeftTirePressureFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'ChassisAxleRow2WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "chassisAxleRow2WheelLeftTirePressure",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = ChassisAxleRow2WheelRightTirePressureFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'ChassisAxleRow2WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "chassisAxleRow2WheelRightTirePressure",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = CurrentLocationLatitudeFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'CurrentLocationLatitude': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "currentLocationLatitude",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = CurrentLocationLongitudeFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'CurrentLocationLongitude': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "currentLocationLongitude",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = ExteriorAirTemperatureFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'ExteriorAirTemperature': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "exteriorAirTemperature",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = PowertrainRangeFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'PowertrainRange': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "powertrainRange",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = PowertrainTractionBatteryChargingAddedEnergyFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'PowertrainTractionBatteryChargingAddedEnergy': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "powertrainTractionBatteryChargingAddedEnergy",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = PowertrainTractionBatteryChargingChargeLimitFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'PowertrainTractionBatteryChargingChargeLimit': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "powertrainTractionBatteryChargingChargeLimit",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = PowertrainTractionBatteryChargingIsChargingFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'PowertrainTractionBatteryChargingIsCharging': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "powertrainTractionBatteryChargingIsCharging",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = PowertrainTractionBatteryCurrentPowerFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'PowertrainTractionBatteryCurrentPower': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "powertrainTractionBatteryCurrentPower",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = PowertrainTractionBatteryStateOfChargeCurrentFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'PowertrainTractionBatteryStateOfChargeCurrent': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "powertrainTractionBatteryStateOfChargeCurrent",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = PowertrainTransmissionTravelledDistanceFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'PowertrainTransmissionTravelledDistance': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "powertrainTransmissionTravelledDistance",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, ts, err = SpeedFromTesla(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to convert 'Speed': %w", err))
		}
	} else {
		sig := vss.SignalValue{
			Name:      "speed",
			Timestamp: ts,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
	return retSignals, errs
}

var zeroTime time.Time

// ChassisAxleRow1WheelLeftTirePressureFromTesla converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftTirePressureFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.vehicle_state.tpms_pressure_fl")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("vehicle_state.tpms_pressure_fl", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.vehicle_state.tpms_pressure_fl'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.vehicle_state.tpms_pressure_fl': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.vehicle_state.tpms_pressure_fl' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'ChassisAxleRow1WheelLeftTirePressure'", errNotFound)
	}

	return ret, zeroTime, errs
}

// ChassisAxleRow1WheelRightTirePressureFromTesla converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightTirePressureFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.vehicle_state.tpms_pressure_fr")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightTirePressure0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("vehicle_state.tpms_pressure_fr", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.vehicle_state.tpms_pressure_fr'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.vehicle_state.tpms_pressure_fr': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.vehicle_state.tpms_pressure_fr' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'ChassisAxleRow1WheelRightTirePressure'", errNotFound)
	}

	return ret, zeroTime, errs
}

// ChassisAxleRow2WheelLeftTirePressureFromTesla converts the given JSON data to a float64.
func ChassisAxleRow2WheelLeftTirePressureFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.vehicle_state.tpms_pressure_rl")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("vehicle_state.tpms_pressure_rl", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.vehicle_state.tpms_pressure_rl'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.vehicle_state.tpms_pressure_rl': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.vehicle_state.tpms_pressure_rl' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'ChassisAxleRow2WheelLeftTirePressure'", errNotFound)
	}

	return ret, zeroTime, errs
}

// ChassisAxleRow2WheelRightTirePressureFromTesla converts the given JSON data to a float64.
func ChassisAxleRow2WheelRightTirePressureFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.vehicle_state.tpms_pressure_rr")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelRightTirePressure0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("vehicle_state.tpms_pressure_rr", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.vehicle_state.tpms_pressure_rr'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.vehicle_state.tpms_pressure_rr': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.vehicle_state.tpms_pressure_rr' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'ChassisAxleRow2WheelRightTirePressure'", errNotFound)
	}

	return ret, zeroTime, errs
}

// CurrentLocationLatitudeFromTesla converts the given JSON data to a float64.
func CurrentLocationLatitudeFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.drive_state.latitude")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLatitude0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("drive_state.latitude", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.drive_state.latitude'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.drive_state.latitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.drive_state.latitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'CurrentLocationLatitude'", errNotFound)
	}

	return ret, zeroTime, errs
}

// CurrentLocationLongitudeFromTesla converts the given JSON data to a float64.
func CurrentLocationLongitudeFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.drive_state.longitude")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLongitude0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("drive_state.longitude", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.drive_state.longitude'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.drive_state.longitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.drive_state.longitude' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'CurrentLocationLongitude'", errNotFound)
	}

	return ret, zeroTime, errs
}

// ExteriorAirTemperatureFromTesla converts the given JSON data to a float64.
func ExteriorAirTemperatureFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.climate_state.outside_temp")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToExteriorAirTemperature0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("climate_state.outside_temp", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.climate_state.outside_temp'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.climate_state.outside_temp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.climate_state.outside_temp' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'ExteriorAirTemperature'", errNotFound)
	}

	return ret, zeroTime, errs
}

// PowertrainRangeFromTesla converts the given JSON data to a float64.
func PowertrainRangeFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charge_state.battery_range")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainRange0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("charge_state.battery_range", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.charge_state.battery_range'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charge_state.battery_range': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charge_state.battery_range' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'PowertrainRange'", errNotFound)
	}

	return ret, zeroTime, errs
}

// PowertrainTractionBatteryChargingAddedEnergyFromTesla converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingAddedEnergyFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charge_state.charge_energy_added")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingAddedEnergy0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("charge_state.charge_energy_added", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.charge_state.charge_energy_added'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charge_state.charge_energy_added': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charge_state.charge_energy_added' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'PowertrainTractionBatteryChargingAddedEnergy'", errNotFound)
	}

	return ret, zeroTime, errs
}

// PowertrainTractionBatteryChargingChargeLimitFromTesla converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingChargeLimitFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charge_state.charge_limit_soc")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingChargeLimit0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("charge_state.charge_limit_soc", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.charge_state.charge_limit_soc'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charge_state.charge_limit_soc': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charge_state.charge_limit_soc' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'PowertrainTractionBatteryChargingChargeLimit'", errNotFound)
	}

	return ret, zeroTime, errs
}

// PowertrainTractionBatteryChargingIsChargingFromTesla converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingIsChargingFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charge_state.charging_state")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingIsCharging0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("charge_state.charging_state", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.charge_state.charging_state'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charge_state.charging_state': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charge_state.charging_state' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'PowertrainTractionBatteryChargingIsCharging'", errNotFound)
	}

	return ret, zeroTime, errs
}

// PowertrainTractionBatteryCurrentPowerFromTesla converts the given JSON data to a float64.
func PowertrainTractionBatteryCurrentPowerFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.drive_state.power")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryCurrentPower0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("drive_state.power", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.drive_state.power'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.drive_state.power': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.drive_state.power' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'PowertrainTractionBatteryCurrentPower'", errNotFound)
	}

	return ret, zeroTime, errs
}

// PowertrainTractionBatteryStateOfChargeCurrentFromTesla converts the given JSON data to a float64.
func PowertrainTractionBatteryStateOfChargeCurrentFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charge_state.battery_level")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryStateOfChargeCurrent0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("charge_state.battery_level", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.charge_state.battery_level'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charge_state.battery_level': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charge_state.battery_level' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'PowertrainTractionBatteryStateOfChargeCurrent'", errNotFound)
	}

	return ret, zeroTime, errs
}

// PowertrainTransmissionTravelledDistanceFromTesla converts the given JSON data to a float64.
func PowertrainTransmissionTravelledDistanceFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.vehicle_state.odometer")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTransmissionTravelledDistance0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("vehicle_state.odometer", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.vehicle_state.odometer'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.vehicle_state.odometer': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.vehicle_state.odometer' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'PowertrainTransmissionTravelledDistance'", errNotFound)
	}

	return ret, zeroTime, errs
}

// SpeedFromTesla converts the given JSON data to a float64.
func SpeedFromTesla(jsonData []byte) (ret float64, ts time.Time, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.drive_state.speed")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToSpeed0(jsonData, val)
			if err == nil {
				endpoint, _, _ := strings.Cut("drive_state.speed", ".")
				result := gjson.GetBytes(jsonData, "data."+endpoint+".timestamp")

				if result.Exists() && result.Type == gjson.Number {
					ts := time.UnixMilli(result.Int())
					return retVal, ts, nil
				}

				errs = errors.Join(errs, fmt.Errorf("couldn't find a timestamp for 'data.drive_state.speed'"))
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.drive_state.speed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.drive_state.speed' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, zeroTime, fmt.Errorf("%w 'Speed'", errNotFound)
	}

	return ret, zeroTime, errs
}
