// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package autopi


// SignalsFromData converts the given JSON data to a slice of signals.
func SignalsFromV2Data(originalDoc []byte, timestamp time.Time, signalName string, sigResult gjson.Result) ([]vss.SignalValue, error) {
	valResult := sigResult.Get("value")
	if !valResult.Exists() {
		return nil, errors.New("value field not found")
	}
	ret := make([]vss.SignalValue, 0)
	var retErrs error
	{{ $root := . }}
	switch signalName {
	{{- range $i, $origInfo := .OriginalNames }}
	case "{{ $origInfo.Name }}":
		{{- range $j, $sig := $origInfo.Signals }}
		val{{ $j }}, err := {{ $sig.GOName }}FromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert '{{ $origInfo.Name }}': %w", err))
		} else {
			sig := vss.SignalValue{
				Timestamp: timestamp,
				Name: "{{ $sig.JSONName }}",
			}
			sig.SetValue(val{{ $j }})
			ret = append(ret, sig)
		}
		{{- end }}
	{{- end }}
	default:
		// do nothing
	}
	return ret, retErrs
}


{{- range $i, $sig := .Signals }}
// {{ $sig.GOName }}FromData converts the given JSON data to a {{ $sig.GOType }}.
func {{ .GOName }}FromV2Data(originalDoc []byte, result gjson.Result) (ret {{ .BaseGoType }}, err error) {
    var errs error
	{{- range $j, $conv := .Conversions }}
	{{ if $conv.IsArray -}}
	if result.IsArray() {
		slice{{ $sig.GOName}} := make([]{{ $conv.OriginalType }}, len(result.Array()))
		for i, res := range result.Array() {
			v, ok := res.Value().({{ $conv.OriginalType }})
			if ok{
				slice{{ $sig.GOName}}[i] = v
			} else {
				errs = errors.Join(errs, fmt.Errorf("%w, field '{{ $conv.OriginalName }}' array element %d is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'", convert.InvalidTypeError(), i, res.Value(), res.Value()))
			}
		}
		ret, err = To{{ $sig.GOName }}{{ $j }}(originalDoc, slice{{ $sig.GOName}})
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert '{{ $sig.Conversion.OriginalName }}': %w", err))
	} else {
		errs = errros.Join(errs, fmt.Errorf("%w, field '{{ $conv.OriginalName }}' is not an array", convert.InvalidTypeError()))
	}
	{{ else -}}
	val{{ $j }}, ok := result.Value().({{ $conv.OriginalType }})
	if ok {
		ret, err = To{{ $sig.GOName }}{{ $j }}(originalDoc, val{{ $j }})
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert '{{ $conv.OriginalName }}': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field '{{ $conv.OriginalName }}' is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	{{- end }}
	{{- end }}

    return ret, errs
}
{{- end }}
