// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package ruptela

import (
	"errors"
	"fmt"

	"github.com/DIMO-Network/model-garage/pkg/convert"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// SignalValue represents a converted signal value along with its original value
type SignalValue struct {
	SignalName     string      `json:"signalName"`
	OriginalValue  interface{} `json:"originalValue"`
	ConvertedValue interface{} `json:"convertedValue"`
}

// ReplaceSignalsFromV1Data creates a slice of vss.Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func ReplaceSignalsFromV1Data(jsonData []byte) ([]byte, []error) {

	var val SignalValue
	var err error
	var errs []error
	var path string

	val, path, err = ReplaceChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelLeftTirePressure': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelRightTirePressure': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelLeftTirePressure': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelRightTirePressure': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceCurrentLocationAltitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationAltitude': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceCurrentLocationLatitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLatitude': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceCurrentLocationLongitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLongitude': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceDIMOAftermarketHDOPFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketHDOP': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceDIMOAftermarketNSATFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketNSAT': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceExteriorAirTemperatureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ExteriorAirTemperature': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceLowVoltageBatteryCurrentVoltageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'LowVoltageBatteryCurrentVoltage': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceOBDDistanceWithMILFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDDistanceWithMIL': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceOBDRunTimeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDRunTime': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainCombustionEngineECTFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineECT': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEngineOilLevel': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainCombustionEngineEngineOilRelativeLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEngineOilRelativeLevel': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainCombustionEngineSpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineSpeed': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainCombustionEngineTPSFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineTPS': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemAbsoluteLevel': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainFuelSystemRelativeLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemRelativeLevel': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainRangeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainRange': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryStateOfChargeCurrent': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainTransmissionTravelledDistanceFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionTravelledDistance': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplacePowertrainTypeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainType': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}

	val, path, err = ReplaceSpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'Speed': %w", err))
		}
	} else {
		// Replace the original value with SignalValue struct
		jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
			return nil, []error{err}
		}
	}
	return jsonData, errs
}

// ReplaceChassisAxleRow1WheelLeftTirePressureFromV1Data converts the given JSON data to a SignalValue.
func ReplaceChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.960", "payload.data.signals.960"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToChassisAxleRow1WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "chassisAxleRow1WheelLeftTirePressure",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'ChassisAxleRow1WheelLeftTirePressure'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceChassisAxleRow1WheelRightTirePressureFromV1Data converts the given JSON data to a SignalValue.
func ReplaceChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.961", "payload.data.signals.961"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToChassisAxleRow1WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "chassisAxleRow1WheelRightTirePressure",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'ChassisAxleRow1WheelRightTirePressure'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceChassisAxleRow2WheelLeftTirePressureFromV1Data converts the given JSON data to a SignalValue.
func ReplaceChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.962", "payload.data.signals.962"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToChassisAxleRow2WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "chassisAxleRow2WheelLeftTirePressure",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'ChassisAxleRow2WheelLeftTirePressure'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceChassisAxleRow2WheelRightTirePressureFromV1Data converts the given JSON data to a SignalValue.
func ReplaceChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.963", "payload.data.signals.963"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToChassisAxleRow2WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "chassisAxleRow2WheelRightTirePressure",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'ChassisAxleRow2WheelRightTirePressure'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceCurrentLocationAltitudeFromV1Data converts the given JSON data to a SignalValue.
func ReplaceCurrentLocationAltitudeFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.pos.alt", "payload.data.pos.alt"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(float64)
		if ok {
			convertedVal, err := ToCurrentLocationAltitude0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "currentLocationAltitude",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'CurrentLocationAltitude'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceCurrentLocationLatitudeFromV1Data converts the given JSON data to a SignalValue.
func ReplaceCurrentLocationLatitudeFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.pos.lat", "payload.data.pos.lat"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(float64)
		if ok {
			convertedVal, err := ToCurrentLocationLatitude0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "currentLocationLatitude",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'CurrentLocationLatitude'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceCurrentLocationLongitudeFromV1Data converts the given JSON data to a SignalValue.
func ReplaceCurrentLocationLongitudeFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.pos.lon", "payload.data.pos.lon"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(float64)
		if ok {
			convertedVal, err := ToCurrentLocationLongitude0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "currentLocationLongitude",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'CurrentLocationLongitude'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceDIMOAftermarketHDOPFromV1Data converts the given JSON data to a SignalValue.
func ReplaceDIMOAftermarketHDOPFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.pos.hdop", "payload.data.pos.hdop"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(float64)
		if ok {
			convertedVal, err := ToDIMOAftermarketHDOP0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "dimoAftermarketHDOP",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'DIMOAftermarketHDOP'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceDIMOAftermarketNSATFromV1Data converts the given JSON data to a SignalValue.
func ReplaceDIMOAftermarketNSATFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.pos.sat", "payload.data.pos.sat"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(float64)
		if ok {
			convertedVal, err := ToDIMOAftermarketNSAT0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "dimoAftermarketNSAT",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'DIMOAftermarketNSAT'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceExteriorAirTemperatureFromV1Data converts the given JSON data to a SignalValue.
func ReplaceExteriorAirTemperatureFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.97", "payload.data.signals.97"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToExteriorAirTemperature0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "exteriorAirTemperature",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'ExteriorAirTemperature'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceLowVoltageBatteryCurrentVoltageFromV1Data converts the given JSON data to a SignalValue.
func ReplaceLowVoltageBatteryCurrentVoltageFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.29", "payload.data.signals.29"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToLowVoltageBatteryCurrentVoltage0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "lowVoltageBatteryCurrentVoltage",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'LowVoltageBatteryCurrentVoltage'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceOBDDistanceWithMILFromV1Data converts the given JSON data to a SignalValue.
func ReplaceOBDDistanceWithMILFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.102", "payload.data.signals.102"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToOBDDistanceWithMIL0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "obdDistanceWithMIL",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'OBDDistanceWithMIL'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceOBDRunTimeFromV1Data converts the given JSON data to a SignalValue.
func ReplaceOBDRunTimeFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.107", "payload.data.signals.107"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToOBDRunTime0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "obdRunTime",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'OBDRunTime'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainCombustionEngineECTFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainCombustionEngineECTFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.96", "payload.data.signals.96"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainCombustionEngineECT0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainCombustionEngineECT",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainCombustionEngineECT'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainCombustionEngineEngineOilLevelFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.964", "payload.data.signals.964"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainCombustionEngineEngineOilLevel0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainCombustionEngineEngineOilLevel",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainCombustionEngineEngineOilLevel'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainCombustionEngineEngineOilRelativeLevelFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainCombustionEngineEngineOilRelativeLevelFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.964", "payload.data.signals.964"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainCombustionEngineEngineOilRelativeLevel0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainCombustionEngineEngineOilRelativeLevel",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainCombustionEngineEngineOilRelativeLevel'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainCombustionEngineSpeedFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainCombustionEngineSpeedFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.94", "payload.data.signals.94"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainCombustionEngineSpeed0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainCombustionEngineSpeed",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainCombustionEngineSpeed'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainCombustionEngineTPSFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainCombustionEngineTPSFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.103", "payload.data.signals.103"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainCombustionEngineTPS0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainCombustionEngineTPS",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainCombustionEngineTPS'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainFuelSystemAbsoluteLevelFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.642", "payload.data.signals.642"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainFuelSystemAbsoluteLevel0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainFuelSystemAbsoluteLevel",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	// Try both possible paths
	paths = []string{"data.signals.205", "payload.data.signals.205"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainFuelSystemAbsoluteLevel1(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainFuelSystemAbsoluteLevel",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainFuelSystemAbsoluteLevel'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainFuelSystemRelativeLevelFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainFuelSystemRelativeLevelFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.98", "payload.data.signals.98"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainFuelSystemRelativeLevel0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainFuelSystemRelativeLevel",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	// Try both possible paths
	paths = []string{"data.signals.207", "payload.data.signals.207"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainFuelSystemRelativeLevel1(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainFuelSystemRelativeLevel",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainFuelSystemRelativeLevel'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainRangeFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainRangeFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.723", "payload.data.signals.723"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainRange0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainRange",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainRange'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainTractionBatteryStateOfChargeCurrentFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.722", "payload.data.signals.722"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainTractionBatteryStateOfChargeCurrent0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainTractionBatteryStateOfChargeCurrent",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainTractionBatteryStateOfChargeCurrent'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainTransmissionTravelledDistanceFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainTransmissionTravelledDistanceFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.645", "payload.data.signals.645"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainTransmissionTravelledDistance0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainTransmissionTravelledDistance",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	// Try both possible paths
	paths = []string{"data.signals.114", "payload.data.signals.114"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainTransmissionTravelledDistance1(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainTransmissionTravelledDistance",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainTransmissionTravelledDistance'", errNotFound)
	}
	return ret, "", errs
}

// ReplacePowertrainTypeFromV1Data converts the given JSON data to a SignalValue.
func ReplacePowertrainTypeFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.99", "payload.data.signals.99"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainType0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainType",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	// Try both possible paths
	paths = []string{"data.signals.483", "payload.data.signals.483"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToPowertrainType1(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "powertrainType",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'PowertrainType'", errNotFound)
	}
	return ret, "", errs
}

// ReplaceSpeedFromV1Data converts the given JSON data to a SignalValue.
func ReplaceSpeedFromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
	var errs error
	var result gjson.Result
	var paths []string
	var found bool
	// Try both possible paths
	paths = []string{"data.signals.95", "payload.data.signals.95"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(string)
		if ok {
			convertedVal, err := ToSpeed0(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "speed",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	// Try both possible paths
	paths = []string{"data.pos.spd", "payload.data.pos.spd"}
	found = false

	for _, p := range paths {
		result = gjson.GetBytes(jsonData, p)
		if result.Exists() && result.Value() != nil {
			path = p
			found = true
			break
		}
	}

	if found {
		val, ok := result.Value().(float64)
		if ok {
			convertedVal, err := ToSpeed1(jsonData, val)
			if err == nil {
				return SignalValue{
					SignalName:     "speed",
					OriginalValue:  val,
					ConvertedValue: convertedVal,
				}, path, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
		}
	}
	if errs == nil {
		return ret, "", fmt.Errorf("%w 'Speed'", errNotFound)
	}
	return ret, "", errs
}
