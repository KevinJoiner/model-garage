// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package ruptela


// SignalsFromLocationData converts the given JSON data to a slice of signals.
func SignalsFromLocationData(originalDoc []byte, timestamp time.Time, signalName string, valResult gjson.Result) ([]vss.SignalValue, error) {
	ret := make([]vss.SignalValue, 0)
	var retErrs error
	{{ $root := . }}
	switch signalName {
	{{- range $i, $origInfo := .OriginalNames }}
	{{ $nameSplit := regexSplit "\\." $origInfo.Name -1 }}
	{{- if ne (len $nameSplit) 2  }} {{ continue }} {{ end }}
	{{ if ne (index $nameSplit 0) "pos" }} {{ continue }} {{ end }}
	{{- $originalSignalName := index $nameSplit 1 }}

	case "{{ $originalSignalName }}":
		{{- range $j, $sig := $origInfo.Signals }}
		val{{ $j }}, err := {{ $sig.GOName }}FromLocationData(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert '{{ $origInfo.Name }}': %w", err))
		} else {
			sig := vss.SignalValue{
				Timestamp: timestamp,
				Name: "{{ $sig.JSONName }}",
			}
			sig.SetValue(val{{ $j }})
			ret = append(ret, sig)
		}
		{{- end }}
	{{- end }}
	default:
		// do nothing
	}
	return ret, retErrs
}

{{- range $i, $sig := .Signals }}
	{{ $break := true }}
	{{- range $j, $conversionInfo := .Conversions }}
		{{ $nameSplit := regexSplit "\\." $conversionInfo.OriginalName -1 }}
		{{- if ne (len $nameSplit) 2  }} {{ continue }} {{ end }}
		{{ if ne (index $nameSplit 0) "pos" }} {{ continue }} {{ end }}
		{{ $break = false }}
	{{- end }}
	{{- if $break }} {{ continue }} {{ end }}
// {{ $sig.GOName }}FromLocationData converts the given JSON data to a {{ $sig.GOType }}.
func {{ .GOName }}FromLocationData(originalDoc []byte, result gjson.Result) (ret {{ .BaseGoType }}, err error) {
    var errs error
	{{- range $j, $conv := .Conversions }}
	{{ if $conv.IsArray -}}
	if result.IsArray() {
		slice{{ $sig.GOName}} := make([]{{ $conv.OriginalType }}, len(result.Array()))
		for i, res := range result.Array() {
			v, ok := res.Value().({{ $conv.OriginalType }})
			if ok{
				slice{{ $sig.GOName}}[i] = v
			} else {
				errs = errors.Join(errs, fmt.Errorf("%w, field '{{ $conv.OriginalName }}' array element %d is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'", convert.InvalidTypeError(), i, res.Value(), res.Value()))
			}
		}
		ret, err = To{{ $sig.GOName }}{{ $j }}(originalDoc, slice{{ $sig.GOName}})
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert '{{ $sig.Conversion.OriginalName }}': %w", err))
	} else {
		errs = errros.Join(errs, fmt.Errorf("%w, field '{{ $conv.OriginalName }}' is not an array", convert.InvalidTypeError()))
	}
	{{ else -}}
	val{{ $j }}, ok := result.Value().({{ $conv.OriginalType }})
	if ok {
		ret, err = To{{ $sig.GOName }}{{ $j }}(originalDoc, val{{ $j }})
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert '{{ $conv.OriginalName }}': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field '{{ $conv.OriginalName }}' is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
	}
	{{- end }}
	{{- end }}

    return ret, errs
}
{{- end }}
