// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package ruptela

import (
    "github.com/tidwall/gjson"
    "github.com/tidwall/sjson"
)

// SignalValue represents a converted signal value along with its original value
type SignalValue struct {
    SignalName    string      `json:"signalName"`
    OriginalValue interface{} `json:"originalValue"`
    ConvertedValue interface{} `json:"convertedValue"`
}


// ReplaceSignalsFromV1Data creates a slice of vss.Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func ReplaceSignalsFromV1Data(jsonData []byte) ([]byte,[]error) {
{{ $first := true -}}
{{- $root := . }}
{{- range $idx, $sig := .Signals }}
{{ if eq (len $sig.Conversions) 0 }} {{ continue }} {{ end -}}
{{ if $first -}}
    var val SignalValue
    var err error
    var errs []error
    var path string
{{ $first = false }} {{ end }}
    val, path, err = Replace{{ $sig.GOName }}FromV1Data(jsonData)
    if err != nil {
        if !errors.Is(err, errNotFound) {
            errs = append(errs, fmt.Errorf("failed to get '{{ $sig.GOName }}': %w", err))
        }
    } else {
        // Replace the original value with SignalValue struct
        jsonData, err = sjson.SetBytes(jsonData, path, val)
		if err != nil {
            return nil, []error{err}
        }
    }
{{- end }}
    return jsonData, errs
}

{{- range $i, $sig := .Signals }}
// Replace{{ $sig.GOName }}FromV1Data converts the given JSON data to a SignalValue.
func Replace{{ $sig.GOName }}FromV1Data(jsonData []byte) (ret SignalValue, path string, err error) {
    var errs error
    var result gjson.Result
	var paths []string
	var found bool
{{- range $j, $conv := .Conversions }}
    // Try both possible paths
    paths = []string{"data.{{ $conv.OriginalName }}", "payload.data.{{ $conv.OriginalName }}"}
    found = false
    
    for _, p := range paths {
        result = gjson.GetBytes(jsonData, p)
        if result.Exists() && result.Value() != nil {
            path = p
            found = true
            break
        }
    }
    
    if found {
{{ if $conv.IsArray -}}
        if result.IsArray() {
            slice{{ $sig.GOName}} := make([]{{ $conv.OriginalType }}, len(result.Array()))
            for i, res := range result.Array() {
                v, ok := res.Value().({{ $conv.OriginalType }})
                if ok {
                    slice{{ $sig.GOName}}[i] = v
                } else {
                    errs = errors.Join(errs, fmt.Errorf("%w, field '%s' array element %d is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'", convert.InvalidTypeError(), path, i, res.Value(), res.Value()))
                }
            }
            convertedVal, err := To{{ $sig.GOName }}{{ $j }}(jsonData, slice{{ $sig.GOName}})
            if err == nil {
                return SignalValue{
                    SignalName: "{{ $sig.JSONName }}",
                    OriginalValue: slice{{ $sig.GOName}},
                    ConvertedValue: convertedVal,
                }, path, nil
            }
            errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
        } else {
            errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not an array", convert.InvalidTypeError(), path))
        }
{{ else -}}
        val, ok := result.Value().({{ $conv.OriginalType }})
        if ok {
            convertedVal, err := To{{ $sig.GOName }}{{ $j }}(jsonData, val)
            if err == nil {
                return SignalValue{
                    SignalName: "{{ $sig.JSONName }}",
                    OriginalValue: val,
                    ConvertedValue: convertedVal,
                }, path, nil
            }
            errs = errors.Join(errs, fmt.Errorf("failed to convert '%s': %w", path, err))
        } else {
            errs = errors.Join(errs, fmt.Errorf("%w, field '%s' is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'", convert.InvalidTypeError(), path, result.Value(), result.Value()))
        }
{{- end }}
    }
{{- end }}
    if errs == nil {
        return ret, "", fmt.Errorf("%w '{{ $sig.GOName }}'", errNotFound)
    }
    return ret, "", errs
}
{{- end }}