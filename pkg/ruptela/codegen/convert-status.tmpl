// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package ruptela

var errNotFound = errors.New("field not found")

// SignalsFromV1Data creates a slice of vss.SignalValue from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromV1Data(timestamp time.Time, jsonData []byte) ([]vss.SignalValue, []error) {
	var retSignals []vss.SignalValue
{{ $first := true -}}
{{- $root := . }}
{{- range $idx, $sig := .Signals }}
	{{ if eq (len $sig.Conversions) 0 }} {{ continue }} {{ end -}}
	{{ if $first -}}
	var val any
	var err error
	var errs []error
	{{ $first = false }} {{ end }}

	val, err = {{ $sig.GOName }}FromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get '{{ $sig.GOName }}': %w", err))
		}
	}else {
		sig := vss.SignalValue{
			Name: "{{ $sig.JSONName }}",
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
{{- end }}
	return retSignals, errs
}


{{- range $i, $sig := .Signals }}
// {{ $sig.GOName }}FromV1Data converts the given JSON data to a {{ $sig.GOType }}.
func {{ $sig.GOName }}FromV1Data(jsonData []byte) (ret {{ $sig.GOType }}, err error) {
    var errs error
    var result gjson.Result

	{{- range $j, $conv := .Conversions }}
    result = gjson.GetBytes(jsonData, "data.{{ $conv.OriginalName }}")
    if result.Exists() && result.Value() != nil {
		{{ if $conv.IsArray -}}
		if result.IsArray() {
			slice{{ $sig.GOName}} := make([]{{ $conv.OriginalType }}, len(result.Array()))
			for i, res := range result.Array() {
				v, ok := res.Value().({{ $conv.OriginalType }})
				if ok{
					slice{{ $sig.GOName}}[i] = v
				} else {
					errs = errors.Join(errs, fmt.Errorf("%w, field 'data.{{ $conv.OriginalName }}' array element %d is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'",  convert.InvalidTypeError(), i, res.Value(), res.Value()))
				}
			}
			retVal, err = To{{ $sig.GOName }}{{ $j }}(jsonData, slice{{ $sig.GOName}})
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.{{ $sig.Conversion.OriginalName }}': %w", err))
		} else {
			errs = errros.Join(errs, fmt.Errorf("%w, field 'data.{{ $conv.OriginalName }}' is not an array", convert.InvalidTypeError()))
		}
		{{ else -}}
        val, ok := result.Value().({{ $conv.OriginalType }})
        if ok {
            retVal, err := To{{ $sig.GOName }}{{ $j }}(jsonData, val)
            if err == nil {
				return retVal, nil
            }
            errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.{{ $conv.OriginalName }}': %w", err))
        } else {
            errs = errors.Join(errs, fmt.Errorf("%w, field 'data.{{ $conv.OriginalName }}' is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'",  convert.InvalidTypeError(), result.Value(), result.Value()))
        }
		{{- end }}
    }
	{{- end }}
	
	if errs == nil {
		return ret, fmt.Errorf("%w '{{ $sig.GOName }}'", errNotFound)
	}

    return ret, errs
}
{{- end }}
